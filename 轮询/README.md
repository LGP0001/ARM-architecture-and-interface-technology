# 轮询
轮询是计算机系统中两种常见的CPU与硬件设备交互的策略。本教程旨在帮助您理解轮询的基本概念、工作原理、优缺点和如何应用。
## 目录
- 简介
- 轮询（polling）
- C编程

<a name="简介"></a>

## 简介
计算机系统的CPU与硬件的交互是一项复杂的任务，涉及多种技术和策略。本章节希望你能了解CPU与硬件的主要交互方式。

### 总线（Bus）
- CPU通过系统总线与外部硬件设备进行通信。这些总线包括数据总线、地址总线和控制总线。
- 数据总线用于传输数据；地址总线用于指定数据来源或目的地的内存地址或I/O地址；控制总线则传递控制信号，如读取、写入等。

### I/O 端口 (Ports)
- 对于一些设备，CPU通过特定的I/O端口进行访问，而不是直接访问内存地址。

### 直接内存访问 (DMA)
- DMA是一种让外部硬件设备（如硬盘控制器、图形卡等）直接访问主内存而无需CPU干预的技术。当大量数据需要在硬件设备和主存之间传输时，DMA可以减轻CPU的负担。

### 中断 (Interrupts)
- 当外部设备需要CPU的注意时（例如，当读取操作完成时），它会发送一个中断信号给CPU。CPU会暂停当前的操作，保存其状态，并处理该中断请求。处理完中断后，CPU会恢复其之前的操作。

### 轮询 (Polling)
- 轮询是CPU定期检查设备状态的另一种方式，以确定是否需要进行任何操作。这与中断相反，因为在轮询中，CPU定期主动去检查，而不是等待设备发出请求。

### 内存映射I/O (Memory-mapped I/O)
- 在此方法中，I/O设备的寄存器被映射到系统的地址空间。这意味着CPU可以使用普通的内存访问指令来访问设备，而不需要特定的I/O指令。

### 握手 (Handshaking)
- 握手是一种两个设备之间的同步机制。例如，一个设备在发送数据之前可能会等待另一个设备发出准备好的信号。

### 设备驱动程序 (Device Drivers)
- 设备驱动程序是一个软件组件，允许操作系统和计算机程序与特定的硬件设备进行交互。它提供了标准化的接口，程序可以使用这些接口与设备通信，而无需知道设备的具体细节。

以上就是CPU与硬件交互的一些主要方式。由于本文主要介绍轮询与中断，因此我会详细介绍这两种交互方式。

<a name="轮询 (Polling)"></a>

## 轮询 (Polling)

### 概念
- 轮询是一种CPU定期检查设备状态的方式，以确定是否需要进行操作。在此过程中，CPU会定期查询或“轮询”一个设备，看看它是否有任何未处理的任务，如数据传输、输入等。

### 工作原理
- CPU定期检查设备的状态寄存器。
- 如果设备忙碌或没有数据，CPU将继续执行其他任务。
- 如果设备准备好或有数据可用，CPU将与之交互。

### 优缺点

#### 优点：

- 实现简单，不需要复杂的硬件或软件支持。

#### 缺点：

- 效率低，因为CPU必须定期检查设备，即使设备没有准备好或没有数据。
- 可能会引起CPU的过度轮询，导致CPU资源浪费。

<a name="C编程"></a>

## C编程

### 编程要求
- 使用轮询的方式检测Key3按键的状态，实现按一次按键，LED2点亮，再次按下，LED2熄灭

### 前期准备
- 电路逻辑分析：通过电路原理图我们可以确定Key3按键的控制逻辑。结论是，当按键被按下时，对应的GPIO端口会读到低电平；当按键释放，对应的GPIO端口则会读到高电平。
<img src="./picture/FS4412 DevBoard Key.png" alt="FS4412 DevBoard Key" width="500"/>
<img src="./picture/FS4412 DevBoard LED.png" alt="FS4412 DevBoard LED" width="500"/>

- Key3与Exynos4412的连接：参照电路原理图，我们找到Key3是连接到Exynos4412的GPX1_2上的。而LED2则连接在GPX2_7。
<img src="./picture/FS4412 CoreBoard Key LED.png" alt="FS4412 CoreBoard Key LED" width="600"/>

- 控制Key3和LED2的寄存器：通过查阅数据手册，我们确定可以通过操作GPX1CON, GPX1DAT寄存器来检测Key3的状态，并通过GPX2CON和GPX2DAT寄存器来实现对LED2的控制。

- 程序控制：根据以上硬件信息和分析结果，我们通过C程序对指定寄存器进行操作，从而实现对LED2的控制，以及检测Key3的状态。

### 实现步骤
1. 初始化：为LED2和Key3设置GPIO。确保LED2为输出模式，Key3为输入模式。

```c
#include "exynos_4412.h"

void GPIO_Config(void)
{
	// 初始化LED2为输出模式
	GPX2.CON &= (~(0xF << 28)); 				// 清零GPX2_7的配置位
    GPX2.CON |= (1 << 28);      				// 设置GPX2_7为输出模式
    GPX2.DAT &= ~(1 << 7);      				// 初始化LED2为熄灭状态

	// 初始化KEY3为输入模式
	GPX1.CON &= (~(0xF << 8)); 				 	// 清零GPX1_2的配置位
	GPX1.CON &= ~(1 << 8);  					// 设置GPX1_2为输入模式
}
```

2. 主循环与轮询  
- 满足C99标准：
```c
int main()
{
	int is_LED_ON = 0;    									// 0代表LED熄灭，1代表LED点亮
	GPIO_Config();

	while (1) 												// 无限循环
	{
		if((GPX1.DAT & (1 << 2)) == 0) 						// 检测Key3是否被按下
		{
			if(is_LED_ON == 0)
			{
				GPX2.DAT |= (1 << 7); 						// 点亮LED2
				is_LED_ON = 1;		  						// 更新标志
			}
			else
			{
				GPX2.DAT &= ~(1 << 7);      				// 熄灭LED2
				is_LED_ON = 0;		  						// 更新标志
			}

			// 为了防止按键反跳，加入一个简单的延时
            for (int delay = 0; delay < 10000; delay++);

			// 等待按键释放
            while ((GPX1.DAT & (1 << 2)) == 0);
            
            // 为了防止按键再次反跳，再加入一个简单的延时
            for (int delay = 0; delay < 10000; delay++);
		}
	}
	
	return 0;
}
```

- 满足C89/C90标准：
```c
int main()
{
	int is_LED_ON = 0;    									// 0代表LED熄灭，1代表LED点亮
	int delay = 0;											
	GPIO_Config();

	while (1) 												// 无限循环
	{
		if((GPX1.DAT & (1 << 2)) == 0) 						// 检测Key3是否被按下
		{
			if(is_LED_ON == 0)
			{
				GPX2.DAT |= (1 << 7); 						// 点亮LED2
				is_LED_ON = 1;		  						// 更新标志
			}
			else
			{
				GPX2.DAT &= ~(1 << 7);      				// 熄灭LED2
				is_LED_ON = 0;		  						// 更新标志
			}

			// 为了防止按键反跳，加入一个简单的延时
            for (delay = 0; delay < 1000000; delay++);

			// 等待按键释放
            while ((GPX1.DAT & (1 << 2)) == 0);
            
            // 为了防止按键再次反跳，再加入一个简单的延时
            for (delay = 0; delay < 1000000; delay++);
		}
	}
	
	return 0;
}
```
3. 编译和部署：
- 使用gcc编译功能编译程序。
- 使用Tera烧录到FS4412开发板。
- 重置或启动开发板并测试程序的功能。













